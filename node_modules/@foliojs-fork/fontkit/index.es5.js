'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var r = _interopDefault(require('@foliojs-fork/restructure'));
var utils = require('@foliojs-fork/restructure/src/utils');
var isEqual = _interopDefault(require('deep-equal'));
var unicode = _interopDefault(require('unicode-properties'));
var UnicodeTrie = _interopDefault(require('unicode-trie'));
var StateMachine = _interopDefault(require('dfa'));
var cloneDeep = _interopDefault(require('clone'));
var inflate = _interopDefault(require('tiny-inflate'));
var brotli = _interopDefault(require('brotli/decompress'));

var fs = require('fs');

var fontkit = {};
fontkit.logErrors = false;
var formats = [];

fontkit.registerFormat = function (format) {
  formats.push(format);
};

fontkit.openSync = function (filename, postscriptName) {
  var buffer = fs.readFileSync(filename);
  return fontkit.create(buffer, postscriptName);
};

fontkit.open = function (filename, postscriptName, callback) {
  if (typeof postscriptName === 'function') {
    callback = postscriptName;
    postscriptName = null;
  }

  fs.readFile(filename, function (err, buffer) {
    if (err) {
      return callback(err);
    }

    try {
      var font = fontkit.create(buffer, postscriptName);
    } catch (e) {
      return callback(e);
    }

    return callback(null, font);
  });
  return;
};

fontkit.create = function (buffer, postscriptName) {
  for (var i = 0; i < formats.length; i++) {
    var format = formats[i];

    if (format.probe(buffer)) {
      var font = new format(new r.DecodeStream(buffer));

      if (postscriptName) {
        return font.getFont(postscriptName);
      }

      return font;
    }
  }

  throw new Error('Unknown font format');
};

fontkit.defaultLanguage = 'en';

fontkit.setDefaultLanguage = function () {
  var lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'en';
  fontkit.defaultLanguage = lang;
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * This decorator caches the results of a getter or method such that
 * the results are lazily computed once, and then cached.
 * @private
 */
function cache(target, key, descriptor) {
  if (descriptor.get) {
    var get = descriptor.get;

    descriptor.get = function () {
      var value = get.call(this);
      Object.defineProperty(this, key, {
        value: value
      });
      return value;
    };
  } else if (typeof descriptor.value === 'function') {
    var fn = descriptor.value;
    return {
      get: function get() {
        var cache = new Map();

        function memoized() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var key = args.length > 0 ? args[0] : 'value';

          if (cache.has(key)) {
            return cache.get(key);
          }

          var result = fn.apply(this, args);
          cache.set(key, result);
          return result;
        }
        Object.defineProperty(this, key, {
          value: memoized
        });
        return memoized;
      }
    };
  }
}

var SubHeader = new r.Struct({
  firstCode: r.uint16,
  entryCount: r.uint16,
  idDelta: r.int16,
  idRangeOffset: r.uint16
});
var CmapGroup = new r.Struct({
  startCharCode: r.uint32,
  endCharCode: r.uint32,
  glyphID: r.uint32
});
var UnicodeValueRange = new r.Struct({
  startUnicodeValue: r.uint24,
  additionalCount: r.uint8
});
var UVSMapping = new r.Struct({
  unicodeValue: r.uint24,
  glyphID: r.uint16
});
var DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);
var NonDefaultUVS = new r.Array(UVSMapping, r.uint32);
var VarSelectorRecord = new r.Struct({
  varSelector: r.uint24,
  defaultUVS: new r.Pointer(r.uint32, DefaultUVS, {
    type: 'parent'
  }),
  nonDefaultUVS: new r.Pointer(r.uint32, NonDefaultUVS, {
    type: 'parent'
  })
});
var CmapSubtable = new r.VersionedStruct(r.uint16, {
  0: {
    // Byte encoding
    length: r.uint16,
    // Total table length in bytes (set to 262 for format 0)
    language: r.uint16,
    // Language code for this encoding subtable, or zero if language-independent
    codeMap: new r.LazyArray(r.uint8, 256)
  },
  2: {
    // High-byte mapping (CJK)
    length: r.uint16,
    language: r.uint16,
    subHeaderKeys: new r.Array(r.uint16, 256),
    subHeaderCount: function subHeaderCount(t) {
      return Math.max.apply(Math, t.subHeaderKeys);
    },
    subHeaders: new r.LazyArray(SubHeader, 'subHeaderCount'),
    glyphIndexArray: new r.LazyArray(r.uint16, 'subHeaderCount')
  },
  4: {
    // Segment mapping to delta values
    length: r.uint16,
    // Total table length in bytes
    language: r.uint16,
    // Language code
    segCountX2: r.uint16,
    segCount: function segCount(t) {
      return t.segCountX2 >> 1;
    },
    searchRange: r.uint16,
    entrySelector: r.uint16,
    rangeShift: r.uint16,
    endCode: new r.LazyArray(r.uint16, 'segCount'),
    reservedPad: new r.Reserved(r.uint16),
    // This value should be zero
    startCode: new r.LazyArray(r.uint16, 'segCount'),
    idDelta: new r.LazyArray(r.int16, 'segCount'),
    idRangeOffset: new r.LazyArray(r.uint16, 'segCount'),
    glyphIndexArray: new r.LazyArray(r.uint16, function (t) {
      return (t.length - t._currentOffset) / 2;
    })
  },
  6: {
    // Trimmed table
    length: r.uint16,
    language: r.uint16,
    firstCode: r.uint16,
    entryCount: r.uint16,
    glyphIndices: new r.LazyArray(r.uint16, 'entryCount')
  },
  8: {
    // mixed 16-bit and 32-bit coverage
    reserved: new r.Reserved(r.uint16),
    length: r.uint32,
    language: r.uint16,
    is32: new r.LazyArray(r.uint8, 8192),
    nGroups: r.uint32,
    groups: new r.LazyArray(CmapGroup, 'nGroups')
  },
  10: {
    // Trimmed Array
    reserved: new r.Reserved(r.uint16),
    length: r.uint32,
    language: r.uint32,
    firstCode: r.uint32,
    entryCount: r.uint32,
    glyphIndices: new r.LazyArray(r.uint16, 'numChars')
  },
  12: {
    // Segmented coverage
    reserved: new r.Reserved(r.uint16),
    length: r.uint32,
    language: r.uint32,
    nGroups: r.uint32,
    groups: new r.LazyArray(CmapGroup, 'nGroups')
  },
  13: {
    // Many-to-one range mappings (same as 12 except for group.startGlyphID)
    reserved: new r.Reserved(r.uint16),
    length: r.uint32,
    language: r.uint32,
    nGroups: r.uint32,
    groups: new r.LazyArray(CmapGroup, 'nGroups')
  },
  14: {
    // Unicode Variation Sequences
    length: r.uint32,
    numRecords: r.uint32,
    varSelectors: new r.LazyArray(VarSelectorRecord, 'numRecords')
  }
});
var CmapEntry = new r.Struct({
  platformID: r.uint16,
  // Platform identifier
  encodingID: r.uint16,
  // Platform-specific encoding identifier
  table: new r.Pointer(r.uint32, CmapSubtable, {
    type: 'parent',
    lazy: true
  })
}); // character to glyph mapping

var cmap = new r.Struct({
  version: r.uint16,
  numSubtables: r.uint16,
  tables: new r.Array(CmapEntry, 'numSubtables')
});

var head = new r.Struct({
  version: r.int32,
  // 0x00010000 (version 1.0)
  revision: r.int32,
  // set by font manufacturer
  checkSumAdjustment: r.uint32,
  magicNumber: r.uint32,
  // set to 0x5F0F3CF5
  flags: r.uint16,
  unitsPerEm: r.uint16,
  // range from 64 to 16384
  created: new r.Array(r.int32, 2),
  modified: new r.Array(r.int32, 2),
  xMin: r.int16,
  // for all glyph bounding boxes
  yMin: r.int16,
  // for all glyph bounding boxes
  xMax: r.int16,
  // for all glyph bounding boxes
  yMax: r.int16,
  // for all glyph bounding boxes
  macStyle: new r.Bitfield(r.uint16, ['bold', 'italic', 'underline', 'outline', 'shadow', 'condensed', 'extended']),
  lowestRecPPEM: r.uint16,
  // smallest readable size in pixels
  fontDirectionHint: r.int16,
  indexToLocFormat: r.int16,
  // 0 for short offsets, 1 for long
  glyphDataFormat: r.int16 // 0 for current format

});

var hhea = new r.Struct({
  version: r.int32,
  ascent: r.int16,
  // Distance from baseline of highest ascender
  descent: r.int16,
  // Distance from baseline of lowest descender
  lineGap: r.int16,
  // Typographic line gap
  advanceWidthMax: r.uint16,
  // Maximum advance width value in 'hmtx' table
  minLeftSideBearing: r.int16,
  // Maximum advance width value in 'hmtx' table
  minRightSideBearing: r.int16,
  // Minimum right sidebearing value
  xMaxExtent: r.int16,
  caretSlopeRise: r.int16,
  // Used to calculate the slope of the cursor (rise/run); 1 for vertical
  caretSlopeRun: r.int16,
  // 0 for vertical
  caretOffset: r.int16,
  // Set to 0 for non-slanted fonts
  reserved: new r.Reserved(r.int16, 4),
  metricDataFormat: r.int16,
  // 0 for current format
  numberOfMetrics: r.uint16 // Number of advance widths in 'hmtx' table

});

var HmtxEntry = new r.Struct({
  advance: r.uint16,
  bearing: r.int16
});
var hmtx = new r.Struct({
  metrics: new r.LazyArray(HmtxEntry, function (t) {
    return t.parent.hhea.numberOfMetrics;
  }),
  bearings: new r.LazyArray(r.int16, function (t) {
    return t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics;
  })
});

var maxp = new r.Struct({
  version: r.int32,
  numGlyphs: r.uint16,
  // The number of glyphs in the font
  maxPoints: r.uint16,
  // Maximum points in a non-composite glyph
  maxContours: r.uint16,
  // Maximum contours in a non-composite glyph
  maxComponentPoints: r.uint16,
  // Maximum points in a composite glyph
  maxComponentContours: r.uint16,
  // Maximum contours in a composite glyph
  maxZones: r.uint16,
  // 1 if instructions do not use the twilight zone, 2 otherwise
  maxTwilightPoints: r.uint16,
  // Maximum points used in Z0
  maxStorage: r.uint16,
  // Number of Storage Area locations
  maxFunctionDefs: r.uint16,
  // Number of FDEFs
  maxInstructionDefs: r.uint16,
  // Number of IDEFs
  maxStackElements: r.uint16,
  // Maximum stack depth
  maxSizeOfInstructions: r.uint16,
  // Maximum byte count for glyph instructions
  maxComponentElements: r.uint16,
  // Maximum number of components referenced at “top level” for any composite glyph
  maxComponentDepth: r.uint16 // Maximum levels of recursion; 1 for simple components

});

/**
 * Gets an encoding name from platform, encoding, and language ids.
 * Returned encoding names can be used in iconv-lite to decode text.
 */
function getEncoding(platformID, encodingID) {
  var languageID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {
    return MAC_LANGUAGE_ENCODINGS[languageID];
  }

  return ENCODINGS[platformID][encodingID];
} // Map of platform ids to encoding ids.

var ENCODINGS = [// unicode
['utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be'], // macintosh
// Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
// 0	Roman                 17	Malayalam
// 1	Japanese	            18	Sinhalese
// 2	Traditional Chinese	  19	Burmese
// 3	Korean	              20	Khmer
// 4	Arabic	              21	Thai
// 5	Hebrew	              22	Laotian
// 6	Greek	                23	Georgian
// 7	Russian	              24	Armenian
// 8	RSymbol	              25	Simplified Chinese
// 9	Devanagari	          26	Tibetan
// 10	Gurmukhi	            27	Mongolian
// 11	Gujarati	            28	Geez
// 12	Oriya	                29	Slavic
// 13	Bengali	              30	Vietnamese
// 14	Tamil	                31	Sindhi
// 15	Telugu	              32	(Uninterpreted)
// 16	Kannada
['macroman', 'shift-jis', 'big5', 'euc-kr', 'iso-8859-6', 'iso-8859-8', 'macgreek', 'maccyrillic', 'symbol', 'Devanagari', 'Gurmukhi', 'Gujarati', 'Oriya', 'Bengali', 'Tamil', 'Telugu', 'Kannada', 'Malayalam', 'Sinhalese', 'Burmese', 'Khmer', 'macthai', 'Laotian', 'Georgian', 'Armenian', 'gb-2312-80', 'Tibetan', 'Mongolian', 'Geez', 'maccenteuro', 'Vietnamese', 'Sindhi'], // ISO (deprecated)
['ascii'], // windows
// Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
['symbol', 'utf16be', 'shift-jis', 'gb18030', 'big5', 'wansung', 'johab', null, null, null, 'utf16be']]; // Overrides for Mac scripts by language id.
// See http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt

var MAC_LANGUAGE_ENCODINGS = {
  15: 'maciceland',
  17: 'macturkish',
  18: 'maccroatian',
  24: 'maccenteuro',
  25: 'maccenteuro',
  26: 'maccenteuro',
  27: 'maccenteuro',
  28: 'maccenteuro',
  30: 'maciceland',
  37: 'macromania',
  38: 'maccenteuro',
  39: 'maccenteuro',
  40: 'maccenteuro',
  143: 'macinuit',
  // Unsupported by iconv-lite
  146: 'macgaelic' // Unsupported by iconv-lite

}; // Map of platform ids to BCP-47 language codes.

var LANGUAGES = [// unicode
[], {
  // macintosh
  0: 'en',
  30: 'fo',
  60: 'ks',
  90: 'rw',
  1: 'fr',
  31: 'fa',
  61: 'ku',
  91: 'rn',
  2: 'de',
  32: 'ru',
  62: 'sd',
  92: 'ny',
  3: 'it',
  33: 'zh',
  63: 'bo',
  93: 'mg',
  4: 'nl',
  34: 'nl-BE',
  64: 'ne',
  94: 'eo',
  5: 'sv',
  35: 'ga',
  65: 'sa',
  128: 'cy',
  6: 'es',
  36: 'sq',
  66: 'mr',
  129: 'eu',
  7: 'da',
  37: 'ro',
  67: 'bn',
  130: 'ca',
  8: 'pt',
  38: 'cz',
  68: 'as',
  131: 'la',
  9: 'no',
  39: 'sk',
  69: 'gu',
  132: 'qu',
  10: 'he',
  40: 'si',
  70: 'pa',
  133: 'gn',
  11: 'ja',
  41: 'yi',
  71: 'or',
  134: 'ay',
  12: 'ar',
  42: 'sr',
  72: 'ml',
  135: 'tt',
  13: 'fi',
  43: 'mk',
  73: 'kn',
  136: 'ug',
  14: 'el',
  44: 'bg',
  74: 'ta',
  137: 'dz',
  15: 'is',
  45: 'uk',
  75: 'te',
  138: 'jv',
  16: 'mt',
  46: 'be',
  76: 'si',
  139: 'su',
  17: 'tr',
  47: 'uz',
  77: 'my',
  140: 'gl',
  18: 'hr',
  48: 'kk',
  78: 'km',
  141: 'af',
  19: 'zh-Hant',
  49: 'az-Cyrl',
  79: 'lo',
  142: 'br',
  20: 'ur',
  50: 'az-Arab',
  80: 'vi',
  143: 'iu',
  21: 'hi',
  51: 'hy',
  81: 'id',
  144: 'gd',
  22: 'th',
  52: 'ka',
  82: 'tl',
  145: 'gv',
  23: 'ko',
  53: 'mo',
  83: 'ms',
  146: 'ga',
  24: 'lt',
  54: 'ky',
  84: 'ms-Arab',
  147: 'to',
  25: 'pl',
  55: 'tg',
  85: 'am',
  148: 'el-polyton',
  26: 'hu',
  56: 'tk',
  86: 'ti',
  149: 'kl',
  27: 'es',
  57: 'mn-CN',
  87: 'om',
  150: 'az',
  28: 'lv',
  58: 'mn',
  88: 'so',
  151: 'nn',
  29: 'se',
  59: 'ps',
  89: 'sw'
}, // ISO (deprecated)
[], {
  // windows                                        
  0x0436: 'af',
  0x4009: 'en-IN',
  0x0487: 'rw',
  0x0432: 'tn',
  0x041C: 'sq',
  0x1809: 'en-IE',
  0x0441: 'sw',
  0x045B: 'si',
  0x0484: 'gsw',
  0x2009: 'en-JM',
  0x0457: 'kok',
  0x041B: 'sk',
  0x045E: 'am',
  0x4409: 'en-MY',
  0x0412: 'ko',
  0x0424: 'sl',
  0x1401: 'ar-DZ',
  0x1409: 'en-NZ',
  0x0440: 'ky',
  0x2C0A: 'es-AR',
  0x3C01: 'ar-BH',
  0x3409: 'en-PH',
  0x0454: 'lo',
  0x400A: 'es-BO',
  0x0C01: 'ar',
  0x4809: 'en-SG',
  0x0426: 'lv',
  0x340A: 'es-CL',
  0x0801: 'ar-IQ',
  0x1C09: 'en-ZA',
  0x0427: 'lt',
  0x240A: 'es-CO',
  0x2C01: 'ar-JO',
  0x2C09: 'en-TT',
  0x082E: 'dsb',
  0x140A: 'es-CR',
  0x3401: 'ar-KW',
  0x0809: 'en-GB',
  0x046E: 'lb',
  0x1C0A: 'es-DO',
  0x3001: 'ar-LB',
  0x0409: 'en',
  0x042F: 'mk',
  0x300A: 'es-EC',
  0x1001: 'ar-LY',
  0x3009: 'en-ZW',
  0x083E: 'ms-BN',
  0x440A: 'es-SV',
  0x1801: 'ary',
  0x0425: 'et',
  0x043E: 'ms',
  0x100A: 'es-GT',
  0x2001: 'ar-OM',
  0x0438: 'fo',
  0x044C: 'ml',
  0x480A: 'es-HN',
  0x4001: 'ar-QA',
  0x0464: 'fil',
  0x043A: 'mt',
  0x080A: 'es-MX',
  0x0401: 'ar-SA',
  0x040B: 'fi',
  0x0481: 'mi',
  0x4C0A: 'es-NI',
  0x2801: 'ar-SY',
  0x080C: 'fr-BE',
  0x047A: 'arn',
  0x180A: 'es-PA',
  0x1C01: 'aeb',
  0x0C0C: 'fr-CA',
  0x044E: 'mr',
  0x3C0A: 'es-PY',
  0x3801: 'ar-AE',
  0x040C: 'fr',
  0x047C: 'moh',
  0x280A: 'es-PE',
  0x2401: 'ar-YE',
  0x140C: 'fr-LU',
  0x0450: 'mn',
  0x500A: 'es-PR',
  0x042B: 'hy',
  0x180C: 'fr-MC',
  0x0850: 'mn-CN',
  0x0C0A: 'es',
  0x044D: 'as',
  0x100C: 'fr-CH',
  0x0461: 'ne',
  0x040A: 'es',
  0x082C: 'az-Cyrl',
  0x0462: 'fy',
  0x0414: 'nb',
  0x540A: 'es-US',
  0x042C: 'az',
  0x0456: 'gl',
  0x0814: 'nn',
  0x380A: 'es-UY',
  0x046D: 'ba',
  0x0437: 'ka',
  0x0482: 'oc',
  0x200A: 'es-VE',
  0x042D: 'eu',
  0x0C07: 'de-AT',
  0x0448: 'or',
  0x081D: 'sv-FI',
  0x0423: 'be',
  0x0407: 'de',
  0x0463: 'ps',
  0x041D: 'sv',
  0x0845: 'bn',
  0x1407: 'de-LI',
  0x0415: 'pl',
  0x045A: 'syr',
  0x0445: 'bn-IN',
  0x1007: 'de-LU',
  0x0416: 'pt',
  0x0428: 'tg',
  0x201A: 'bs-Cyrl',
  0x0807: 'de-CH',
  0x0816: 'pt-PT',
  0x085F: 'tzm',
  0x141A: 'bs',
  0x0408: 'el',
  0x0446: 'pa',
  0x0449: 'ta',
  0x047E: 'br',
  0x046F: 'kl',
  0x046B: 'qu-BO',
  0x0444: 'tt',
  0x0402: 'bg',
  0x0447: 'gu',
  0x086B: 'qu-EC',
  0x044A: 'te',
  0x0403: 'ca',
  0x0468: 'ha',
  0x0C6B: 'qu',
  0x041E: 'th',
  0x0C04: 'zh-HK',
  0x040D: 'he',
  0x0418: 'ro',
  0x0451: 'bo',
  0x1404: 'zh-MO',
  0x0439: 'hi',
  0x0417: 'rm',
  0x041F: 'tr',
  0x0804: 'zh',
  0x040E: 'hu',
  0x0419: 'ru',
  0x0442: 'tk',
  0x1004: 'zh-SG',
  0x040F: 'is',
  0x243B: 'smn',
  0x0480: 'ug',
  0x0404: 'zh-TW',
  0x0470: 'ig',
  0x103B: 'smj-NO',
  0x0422: 'uk',
  0x0483: 'co',
  0x0421: 'id',
  0x143B: 'smj',
  0x042E: 'hsb',
  0x041A: 'hr',
  0x045D: 'iu',
  0x0C3B: 'se-FI',
  0x0420: 'ur',
  0x101A: 'hr-BA',
  0x085D: 'iu-Latn',
  0x043B: 'se',
  0x0843: 'uz-Cyrl',
  0x0405: 'cs',
  0x083C: 'ga',
  0x083B: 'se-SE',
  0x0443: 'uz',
  0x0406: 'da',
  0x0434: 'xh',
  0x203B: 'sms',
  0x042A: 'vi',
  0x048C: 'prs',
  0x0435: 'zu',
  0x183B: 'sma-NO',
  0x0452: 'cy',
  0x0465: 'dv',
  0x0410: 'it',
  0x1C3B: 'sms',
  0x0488: 'wo',
  0x0813: 'nl-BE',
  0x0810: 'it-CH',
  0x044F: 'sa',
  0x0485: 'sah',
  0x0413: 'nl',
  0x0411: 'ja',
  0x1C1A: 'sr-Cyrl-BA',
  0x0478: 'ii',
  0x0C09: 'en-AU',
  0x044B: 'kn',
  0x0C1A: 'sr',
  0x046A: 'yo',
  0x2809: 'en-BZ',
  0x043F: 'kk',
  0x181A: 'sr-Latn-BA',
  0x1009: 'en-CA',
  0x0453: 'km',
  0x081A: 'sr-Latn',
  0x2409: 'en-029',
  0x0486: 'quc',
  0x046C: 'nso'
}];

var NameRecord = new r.Struct({
  platformID: r.uint16,
  encodingID: r.uint16,
  languageID: r.uint16,
  nameID: r.uint16,
  length: r.uint16,
  string: new r.Pointer(r.uint16, new r.String('length', function (t) {
    return getEncoding(t.platformID, t.encodingID, t.languageID);
  }), {
    type: 'parent',
    relativeTo: function relativeTo(ctx) {
      return ctx.parent.stringOffset;
    },
    allowNull: false
  })
});
var LangTagRecord = new r.Struct({
  length: r.uint16,
  tag: new r.Pointer(r.uint16, new r.String('length', 'utf16be'), {
    type: 'parent',
    relativeTo: function relativeTo(ctx) {
      return ctx.stringOffset;
    }
  })
});
var NameTable = new r.VersionedStruct(r.uint16, {
  0: {
    count: r.uint16,
    stringOffset: r.uint16,
    records: new r.Array(NameRecord, 'count')
  },
  1: {
    count: r.uint16,
    stringOffset: r.uint16,
    records: new r.Array(NameRecord, 'count'),
    langTagCount: r.uint16,
    langTags: new r.Array(LangTagRecord, 'langTagCount')
  }
});
var NAMES = ['copyright', 'fontFamily', 'fontSubfamily', 'uniqueSubfamily', 'fullName', 'version', 'postscriptName', // Note: A font may have only one PostScript name and that name must be ASCII.
'trademark', 'manufacturer', 'designer', 'description', 'vendorURL', 'designerURL', 'license', 'licenseURL', null, // reserved
'preferredFamily', 'preferredSubfamily', 'compatibleFull', 'sampleText', 'postscriptCIDFontName', 'wwsFamilyName', 'wwsSubfamilyName'];

NameTable.process = function (stream) {
  var records = {};

  var _iterator = _createForOfIteratorHelper(this.records),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var record = _step.value;
      // find out what language this is for
      var language = LANGUAGES[record.platformID][record.languageID];

      if (language == null && this.langTags != null && record.languageID >= 0x8000) {
        language = this.langTags[record.languageID - 0x8000].tag;
      }

      if (language == null) {
        language = record.platformID + '-' + record.languageID;
      } // if the nameID is >= 256, it is a font feature record (AAT)


      var key = record.nameID >= 256 ? 'fontFeatures' : NAMES[record.nameID] || record.nameID;

      if (records[key] == null) {
        records[key] = {};
      }

      var obj = records[key];

      if (record.nameID >= 256) {
        obj = obj[record.nameID] || (obj[record.nameID] = {});
      }

      if (typeof record.string === 'string' || typeof obj[language] !== 'string') {
        obj[language] = record.string;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  this.records = records;
};

NameTable.preEncode = function () {
  if (Array.isArray(this.records)) return;
  this.version = 0;
  var records = [];

  for (var key in this.records) {
    var val = this.records[key];
    if (key === 'fontFeatures') continue;
    records.push({
      platformID: 3,
      encodingID: 1,
      languageID: 0x409,
      nameID: NAMES.indexOf(key),
      length: Buffer.byteLength(val.en, 'utf16le'),
      string: val.en
    });

    if (key === 'postscriptName') {
      records.push({
        platformID: 1,
        encodingID: 0,
        languageID: 0,
        nameID: NAMES.indexOf(key),
        length: val.en.length,
        string: val.en
      });
    }
  }

  this.records = records;
  this.count = records.length;
  this.stringOffset = NameTable.size(this, null, false);
};

var OS2 = new r.VersionedStruct(r.uint16, {
  header: {
    xAvgCharWidth: r.int16,
    // average weighted advance width of lower case letters and space
    usWeightClass: r.uint16,
    // visual weight of stroke in glyphs
    usWidthClass: r.uint16,
    // relative change from the normal aspect ratio (width to height ratio)
    fsType: new r.Bitfield(r.uint16, [// Indicates font embedding licensing rights
    null, 'noEmbedding', 'viewOnly', 'editable', null, null, null, null, 'noSubsetting', 'bitmapOnly']),
    ySubscriptXSize: r.int16,
    // recommended horizontal size in pixels for subscripts
    ySubscriptYSize: r.int16,
    // recommended vertical size in pixels for subscripts
    ySubscriptXOffset: r.int16,
    // recommended horizontal offset for subscripts
    ySubscriptYOffset: r.int16,
    // recommended vertical offset form the baseline for subscripts
    ySuperscriptXSize: r.int16,
    // recommended horizontal size in pixels for superscripts
    ySuperscriptYSize: r.int16,
    // recommended vertical size in pixels for superscripts
    ySuperscriptXOffset: r.int16,
    // recommended horizontal offset for superscripts
    ySuperscriptYOffset: r.int16,
    // recommended vertical offset from the baseline for superscripts
    yStrikeoutSize: r.int16,
    // width of the strikeout stroke
    yStrikeoutPosition: r.int16,
    // position of the strikeout stroke relative to the baseline
    sFamilyClass: r.int16,
    // classification of font-family design
    panose: new r.Array(r.uint8, 10),
    // describe the visual characteristics of a given typeface
    ulCharRange: new r.Array(r.uint32, 4),
    vendorID: new r.String(4),
    // four character identifier for the font vendor
    fsSelection: new r.Bitfield(r.uint16, [// bit field containing information about the font
    'italic', 'underscore', 'negative', 'outlined', 'strikeout', 'bold', 'regular', 'useTypoMetrics', 'wws', 'oblique']),
    usFirstCharIndex: r.uint16,
    // The minimum Unicode index in this font
    usLastCharIndex: r.uint16 // The maximum Unicode index in this font

  },
  // The Apple version of this table ends here, but the Microsoft one continues on...
  0: {},
  1: {
    typoAscender: r.int16,
    typoDescender: r.int16,
    typoLineGap: r.int16,
    winAscent: r.uint16,
    winDescent: r.uint16,
    codePageRange: new r.Array(r.uint32, 2)
  },
  2: {
    // these should be common with version 1 somehow
    typoAscender: r.int16,
    typoDescender: r.int16,
    typoLineGap: r.int16,
    winAscent: r.uint16,
    winDescent: r.uint16,
    codePageRange: new r.Array(r.uint32, 2),
    xHeight: r.int16,
    capHeight: r.int16,
    defaultChar: r.uint16,
    breakChar: r.uint16,
    maxContent: r.uint16
  },
  5: {
    typoAscender: r.int16,
    typoDescender: r.int16,
    typoLineGap: r.int16,
    winAscent: r.uint16,
    winDescent: r.uint16,
    codePageRange: new r.Array(r.uint32, 2),
    xHeight: r.int16,
    capHeight: r.int16,
    defaultChar: r.uint16,
    breakChar: r.uint16,
    maxContent: r.uint16,
    usLowerOpticalPointSize: r.uint16,
    usUpperOpticalPointSize: r.uint16
  }
});
var versions = OS2.versions;
versions[3] = versions[4] = versions[2];

var post = new r.VersionedStruct(r.fixed32, {
  header: {
    // these fields exist at the top of all versions
    italicAngle: r.fixed32,
    // Italic angle in counter-clockwise degrees from the vertical.
    underlinePosition: r.int16,
    // Suggested distance of the top of the underline from the baseline
    underlineThickness: r.int16,
    // Suggested values for the underline thickness
    isFixedPitch: r.uint32,
    // Whether the font is monospaced
    minMemType42: r.uint32,
    // Minimum memory usage when a TrueType font is downloaded as a Type 42 font
    maxMemType42: r.uint32,
    // Maximum memory usage when a TrueType font is downloaded as a Type 42 font
    minMemType1: r.uint32,
    // Minimum memory usage when a TrueType font is downloaded as a Type 1 font
    maxMemType1: r.uint32 // Maximum memory usage when a TrueType font is downloaded as a Type 1 font

  },
  1: {},
  // version 1 has no additional fields
  2: {
    numberOfGlyphs: r.uint16,
    glyphNameIndex: new r.Array(r.uint16, 'numberOfGlyphs'),
    names: new r.Array(new r.String(r.uint8))
  },
  2.5: {
    numberOfGlyphs: r.uint16,
    offsets: new r.Array(r.uint8, 'numberOfGlyphs')
  },
  3: {},
  // version 3 has no additional fields
  4: {
    map: new r.Array(r.uint32, function (t) {
      return t.parent.maxp.numGlyphs;
    })
  }
});

var cvt = new r.Struct({
  controlValues: new r.Array(r.int16)
});

// These instructions are known as the font program. The main use of this table
// is for the definition of functions that are used in many different glyph programs.

var fpgm = new r.Struct({
  instructions: new r.Array(r.uint8)
});

var loca = new r.VersionedStruct('head.indexToLocFormat', {
  0: {
    offsets: new r.Array(r.uint16)
  },
  1: {
    offsets: new r.Array(r.uint32)
  }
});

loca.process = function () {
  if (this.version === 0) {
    for (var i = 0; i < this.offsets.length; i++) {
      this.offsets[i] <<= 1;
    }
  }
};

loca.preEncode = function () {
  if (this.version === 0) {
    for (var i = 0; i < this.offsets.length; i++) {
      this.offsets[i] >>>= 1;
    }
  }
};

var prep = new r.Struct({
  controlValueProgram: new r.Array(r.uint8)
});

var glyf = new r.Array(new r.Buffer());

var CFFIndex = /*#__PURE__*/function () {
  function CFFIndex(type) {
    _classCallCheck(this, CFFIndex);

    this.type = type;
  }

  _createClass(CFFIndex, [{
    key: "getCFFVersion",
    value: function getCFFVersion(ctx) {
      while (ctx && !ctx.hdrSize) {
        ctx = ctx.parent;
      }

      return ctx ? ctx.version : -1;
    }
  }, {
    key: "decode",
    value: function decode(stream, parent) {
      var version = this.getCFFVersion(parent);
      var count = version >= 2 ? stream.readUInt32BE() : stream.readUInt16BE();

      if (count === 0) {
        return [];
      }

      var offSize = stream.readUInt8();
      var offsetType;

      if (offSize === 1) {
        offsetType = r.uint8;
      } else if (offSize === 2) {
        offsetType = r.uint16;
      } else if (offSize === 3) {
        offsetType = r.uint24;
      } else if (offSize === 4) {
        offsetType = r.uint32;
      } else {
        throw new Error("Bad offset size in CFFIndex: ".concat(offSize, " ").concat(stream.pos));
      }

      var ret = [];
      var startPos = stream.pos + (count + 1) * offSize - 1;
      var start = offsetType.decode(stream);

      for (var i = 0; i < count; i++) {
        var end = offsetType.decode(stream);

        if (this.type != null) {
          var pos = stream.pos;
          stream.pos = startPos + start;
          parent.length = end - start;
          ret.push(this.type.decode(stream, parent));
          stream.pos = pos;
        } else {
          ret.push({
            offset: startPos + start,
            length: end - start
          });
        }

        start = end;
      }

      stream.pos = startPos + start;
      return ret;
    }
  }, {
    key: "size",
    value: function size(arr, parent) {
      var size = 2;

      if (arr.length === 0) {
        return size;
      }

      var type = this.type || new r.Buffer(); // find maximum offset to detminine offset type

      var offset = 1;

      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        offset += type.size(item, parent);
      }

      var offsetType;

      if (offset <= 0xff) {
        offsetType = r.uint8;
      } else if (offset <= 0xffff) {
        offsetType = r.uint16;
      } else if (offset <= 0xffffff) {
        offsetType = r.uint24;
      } else if (offset <= 0xffffffff) {
        offsetType = r.uint32;
      } else {
        throw new Error("Bad offset in CFFIndex");
      }

      size += 1 + offsetType.size() * (arr.length + 1);
      size += offset - 1;
      return size;
    }
  }, {
    key: "encode",
    value: function encode(stream, arr, parent) {
      stream.writeUInt16BE(arr.length);

      if (arr.length === 0) {
        return;
      }

      var type = this.type || new r.Buffer(); // find maximum offset to detminine offset type

      var sizes = [];
      var offset = 1;

      var _iterator = _createForOfIteratorHelper(arr),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;
          var s = type.size(item, parent);
          sizes.push(s);
          offset += s;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var offsetType;

      if (offset <= 0xff) {
        offsetType = r.uint8;
      } else if (offset <= 0xffff) {
        offsetType = r.uint16;
      } else if (offset <= 0xffffff) {
        offsetType = r.uint24;
      } else if (offset <= 0xffffffff) {
        offsetType = r.uint32;
      } else {
        throw new Error("Bad offset in CFFIndex");
      } // write offset size


      stream.writeUInt8(offsetType.size()); // write elements

      offset = 1;
      offsetType.encode(stream, offset);

      for (var _i = 0, _sizes = sizes; _i < _sizes.length; _i++) {
        var size = _sizes[_i];
        offset += size;
        offsetType.encode(stream, offset);
      }

      var _iterator2 = _createForOfIteratorHelper(arr),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _item = _step2.value;
          type.encode(stream, _item, parent);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return;
    }
  }]);

  return CFFIndex;
}();

var FLOAT_EOF = 0xf;
var FLOAT_LOOKUP = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
var FLOAT_ENCODE_LOOKUP = {
  '.': 10,
  'E': 11,
  'E-': 12,
  '-': 14
};

var CFFOperand = /*#__PURE__*/function () {
  function CFFOperand() {
    _classCallCheck(this, CFFOperand);
  }

  _createClass(CFFOperand, null, [{
    key: "decode",
    value: function decode(stream, value) {
      if (32 <= value && value <= 246) {
        return value - 139;
      }

      if (247 <= value && value <= 250) {
        return (value - 247) * 256 + stream.readUInt8() + 108;
      }

      if (251 <= value && value <= 254) {
        return -(value - 251) * 256 - stream.readUInt8() - 108;
      }

      if (value === 28) {
        return stream.readInt16BE();
      }

      if (value === 29) {
        return stream.readInt32BE();
      }

      if (value === 30) {
        var str = '';

        while (true) {
          var b = stream.readUInt8();
          var n1 = b >> 4;

          if (n1 === FLOAT_EOF) {
            break;
          }

          str += FLOAT_LOOKUP[n1];
          var n2 = b & 15;

          if (n2 === FLOAT_EOF) {
            break;
          }

          str += FLOAT_LOOKUP[n2];
        }

        return parseFloat(str);
      }

      return null;
    }
  }, {
    key: "size",
    value: function size(value) {
      // if the value needs to be forced to the largest size (32 bit)
      // e.g. for unknown pointers, set to 32768
      if (value.forceLarge) {
        value = 32768;
      }

      if ((value | 0) !== value) {
        // floating point
        var str = '' + value;
        return 1 + Math.ceil((str.length + 1) / 2);
      } else if (-107 <= value && value <= 107) {
        return 1;
      } else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {
        return 2;
      } else if (-32768 <= value && value <= 32767) {
        return 3;
      } else {
        return 5;
      }
    }
  }, {
    key: "encode",
    value: function encode(stream, value) {
      // if the value needs to be forced to the largest size (32 bit)
      // e.g. for unknown pointers, save the old value and set to 32768
      var val = Number(value);

      if (value.forceLarge) {
        stream.writeUInt8(29);
        return stream.writeInt32BE(val);
      } else if ((val | 0) !== val) {
        // floating point
        stream.writeUInt8(30);
        var str = '' + val;

        for (var i = 0; i < str.length; i += 2) {
          var c1 = str[i];
          var n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;

          if (i === str.length - 1) {
            var n2 = FLOAT_EOF;
          } else {
            var c2 = str[i + 1];
            var n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2;
          }

          stream.writeUInt8(n1 << 4 | n2 & 15);
        }

        if (n2 !== FLOAT_EOF) {
          return stream.writeUInt8(FLOAT_EOF << 4);
        }
      } else if (-107 <= val && val <= 107) {
        return stream.writeUInt8(val + 139);
      } else if (108 <= val && val <= 1131) {
        val -= 108;
        stream.writeUInt8((val >> 8) + 247);
        return stream.writeUInt8(val & 0xff);
      } else if (-1131 <= val && val <= -108) {
        val = -val - 108;
        stream.writeUInt8((val >> 8) + 251);
        return stream.writeUInt8(val & 0xff);
      } else if (-32768 <= val && val <= 32767) {
        stream.writeUInt8(28);
        return stream.writeInt16BE(val);
      } else {
        stream.writeUInt8(29);
        return stream.writeInt32BE(val);
      }
    }
  }]);

  return CFFOperand;
}();

var CFFDict = /*#__PURE__*/function () {
  function CFFDict() {
    var ops = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, CFFDict);

    this.ops = ops;
    this.fields = {};

    var _iterator = _createForOfIteratorHelper(ops),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var field = _step.value;
        var key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
        this.fields[key] = field;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  _createClass(CFFDict, [{
    key: "decodeOperands",
    value: function decodeOperands(type, stream, ret, operands) {
      var _this = this;

      if (Array.isArray(type)) {
        return operands.map(function (op, i) {
          return _this.decodeOperands(type[i], stream, ret, [op]);
        });
      } else if (type.decode != null) {
        return type.decode(stream, ret, operands);
      } else {
        switch (type) {
          case 'number':
          case 'offset':
          case 'sid':
            return operands[0];

          case 'boolean':
            return !!operands[0];

          default:
            return operands;
        }
      }
    }
  }, {
    key: "encodeOperands",
    value: function encodeOperands(type, stream, ctx, operands) {
      var _this2 = this;

      if (Array.isArray(type)) {
        return operands.map(function (op, i) {
          return _this2.encodeOperands(type[i], stream, ctx, op)[0];
        });
      } else if (type.encode != null) {
        return type.encode(stream, operands, ctx);
      } else if (typeof operands === 'number') {
        return [operands];
      } else if (typeof operands === 'boolean') {
        return [+operands];
      } else if (Array.isArray(operands)) {
        return operands;
      } else {
        return [operands];
      }
    }
  }, {
    key: "decode",
    value: function decode(stream, parent) {
      var end = stream.pos + parent.length;
      var ret = {};
      var operands = []; // define hidden properties

      Object.defineProperties(ret, {
        parent: {
          value: parent
        },
        _startOffset: {
          value: stream.pos
        }
      }); // fill in defaults

      for (var key in this.fields) {
        var field = this.fields[key];
        ret[field[1]] = field[3];
      }

      while (stream.pos < end) {
        var b = stream.readUInt8();

        if (b < 28) {
          if (b === 12) {
            b = b << 8 | stream.readUInt8();
          }

          var _field = this.fields[b];

          if (!_field) {
            throw new Error("Unknown operator ".concat(b));
          }

          var val = this.decodeOperands(_field[2], stream, ret, operands);

          if (val != null) {
            if (val instanceof utils.PropertyDescriptor) {
              Object.defineProperty(ret, _field[1], val);
            } else {
              ret[_field[1]] = val;
            }
          }

          operands = [];
        } else {
          operands.push(CFFOperand.decode(stream, b));
        }
      }

      return ret;
    }
  }, {
    key: "size",
    value: function size(dict, parent) {
      var includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var ctx = {
        parent: parent,
        val: dict,
        pointerSize: 0,
        startOffset: parent.startOffset || 0
      };
      var len = 0;

      for (var k in this.fields) {
        var field = this.fields[k];
        var val = dict[field[1]];

        if (val == null || isEqual(val, field[3])) {
          continue;
        }

        var operands = this.encodeOperands(field[2], null, ctx, val);

        var _iterator2 = _createForOfIteratorHelper(operands),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var op = _step2.value;
            len += CFFOperand.size(op);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        var key = Array.isArray(field[0]) ? field[0] : [field[0]];
        len += key.length;
      }

      if (includePointers) {
        len += ctx.pointerSize;
      }

      return len;
    }
  }, {
    key: "encode",
    value: function encode(stream, dict, parent) {
      var ctx = {
        pointers: [],
        startOffset: stream.pos,
        parent: parent,
        val: dict,
        pointerSize: 0
      };
      ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);

      var _iterator3 = _createForOfIteratorHelper(this.ops),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var field = _step3.value;
          var val = dict[field[1]];

          if (val == null || isEqual(val, field[3])) {
            continue;
          }

          var operands = this.encodeOperands(field[2], stream, ctx, val);

          var _iterator4 = _createForOfIteratorHelper(operands),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var op = _step4.value;
              CFFOperand.encode(stream, op);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          var key = Array.isArray(field[0]) ? field[0] : [field[0]];

          var _iterator5 = _createForOfIteratorHelper(key),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _op = _step5.value;
              stream.writeUInt8(_op);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      var i = 0;

      while (i < ctx.pointers.length) {
        var ptr = ctx.pointers[i++];
        ptr.type.encode(stream, ptr.val, ptr.parent);
      }

      return;
    }
  }]);

  return CFFDict;
}();

var CFFPointer = /*#__PURE__*/function (_r$Pointer) {
  _inherits(CFFPointer, _r$Pointer);

  var _super = _createSuper(CFFPointer);

  function CFFPointer(type) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, CFFPointer);

    if (options.type == null) {
      options.type = 'global';
    }

    return _super.call(this, null, type, options);
  }

  _createClass(CFFPointer, [{
    key: "decode",
    value: function decode(stream, parent, operands) {
      this.offsetType = {
        decode: function decode() {
          return operands[0];
        }
      };
      return _get(_getPrototypeOf(CFFPointer.prototype), "decode", this).call(this, stream, parent, operands);
    }
  }, {
    key: "encode",
    value: function encode(stream, value, ctx) {
      if (!stream) {
        // compute the size (so ctx.pointerSize is correct)
        this.offsetType = {
          size: function size() {
            return 0;
          }
        };
        this.size(value, ctx);
        return [new Ptr(0)];
      }

      var ptr = null;
      this.offsetType = {
        encode: function encode(stream, val) {
          return ptr = val;
        }
      };

      _get(_getPrototypeOf(CFFPointer.prototype), "encode", this).call(this, stream, value, ctx);

      return [new Ptr(ptr)];
    }
  }]);

  return CFFPointer;
}(r.Pointer);

var Ptr = /*#__PURE__*/function () {
  function Ptr(val) {
    _classCallCheck(this, Ptr);

    this.val = val;
    this.forceLarge = true;
  }

  _createClass(Ptr, [{
    key: "valueOf",
    value: function valueOf() {
      return this.val;
    }
  }]);

  return Ptr;
}();

var CFFBlendOp = /*#__PURE__*/function () {
  function CFFBlendOp() {
    _classCallCheck(this, CFFBlendOp);
  }

  _createClass(CFFBlendOp, null, [{
    key: "decode",
    value: function decode(stream, parent, operands) {
      var numBlends = operands.pop(); // TODO: actually blend. For now just consume the deltas
      // since we don't use any of the values anyway.

      while (operands.length > numBlends) {
        operands.pop();
      }
    }
  }]);

  return CFFBlendOp;
}();

var CFFPrivateDict = new CFFDict([// key       name                    type                                          default
[6, 'BlueValues', 'delta', null], [7, 'OtherBlues', 'delta', null], [8, 'FamilyBlues', 'delta', null], [9, 'FamilyOtherBlues', 'delta', null], [[12, 9], 'BlueScale', 'number', 0.039625], [[12, 10], 'BlueShift', 'number', 7], [[12, 11], 'BlueFuzz', 'number', 1], [10, 'StdHW', 'number', null], [11, 'StdVW', 'number', null], [[12, 12], 'StemSnapH', 'delta', null], [[12, 13], 'StemSnapV', 'delta', null], [[12, 14], 'ForceBold', 'boolean', false], [[12, 17], 'LanguageGroup', 'number', 0], [[12, 18], 'ExpansionFactor', 'number', 0.06], [[12, 19], 'initialRandomSeed', 'number', 0], [20, 'defaultWidthX', 'number', 0], [21, 'nominalWidthX', 'number', 0], [22, 'vsindex', 'number', 0], [23, 'blend', CFFBlendOp, null], [19, 'Subrs', new CFFPointer(new CFFIndex(), {
  type: 'local'
}), null]]);

// Automatically generated from Appendix A of the CFF specification; do
// not edit. Length should be 391.
var standardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];

var StandardEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger', 'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron', 'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '', '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '', 'lslash', 'oslash', 'oe', 'germandbls'];
var ExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior', '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var ISOAdobeCharset = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron'];
var ExpertCharset = ['.notdef', 'space', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];
var ExpertSubsetCharset = ['.notdef', 'space', 'dollaroldstyle', 'dollarsuperior', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'hyphensuperior', 'colonmonetary', 'onefitted', 'rupiah', 'centoldstyle', 'figuredash', 'hypheninferior', 'onequarter', 'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior'];

// Scripts and Languages #
//########################

var LangSysTable = new r.Struct({
  reserved: new r.Reserved(r.uint16),
  reqFeatureIndex: r.uint16,
  featureCount: r.uint16,
  featureIndexes: new r.Array(r.uint16, 'featureCount')
});
var LangSysRecord = new r.Struct({
  tag: new r.String(4),
  langSys: new r.Pointer(r.uint16, LangSysTable, {
    type: 'parent'
  })
});
var Script = new r.Struct({
  defaultLangSys: new r.Pointer(r.uint16, LangSysTable),
  count: r.uint16,
  langSysRecords: new r.Array(LangSysRecord, 'count')
});
var ScriptRecord = new r.Struct({
  tag: new r.String(4),
  script: new r.Pointer(r.uint16, Script, {
    type: 'parent'
  })
});
var ScriptList = new r.Array(ScriptRecord, r.uint16); //#######################
// Features and Lookups #
//#######################

var Feature = new r.Struct({
  featureParams: r.uint16,
  // pointer
  lookupCount: r.uint16,
  lookupListIndexes: new r.Array(r.uint16, 'lookupCount')
});
var FeatureRecord = new r.Struct({
  tag: new r.String(4),
  feature: new r.Pointer(r.uint16, Feature, {
    type: 'parent'
  })
});
var FeatureList = new r.Array(FeatureRecord, r.uint16);
var LookupFlags = new r.Struct({
  markAttachmentType: r.uint8,
  flags: new r.Bitfield(r.uint8, ['rightToLeft', 'ignoreBaseGlyphs', 'ignoreLigatures', 'ignoreMarks', 'useMarkFilteringSet'])
});
function LookupList(SubTable) {
  var Lookup = new r.Struct({
    lookupType: r.uint16,
    flags: LookupFlags,
    subTableCount: r.uint16,
    subTables: new r.Array(new r.Pointer(r.uint16, SubTable), 'subTableCount'),
    markFilteringSet: new r.Optional(r.uint16, function (t) {
      return t.flags.flags.useMarkFilteringSet;
    })
  });
  return new r.LazyArray(new r.Pointer(r.uint16, Lookup), r.uint16);
} //#################
// Coverage Table #
//#################

var RangeRecord = new r.Struct({
  start: r.uint16,
  end: r.uint16,
  startCoverageIndex: r.uint16
});
var Coverage = new r.VersionedStruct(r.uint16, {
  1: {
    glyphCount: r.uint16,
    glyphs: new r.Array(r.uint16, 'glyphCount')
  },
  2: {
    rangeCount: r.uint16,
    rangeRecords: new r.Array(RangeRecord, 'rangeCount')
  }
}); //#########################
// Class Definition Table #
//#########################

var ClassRangeRecord = new r.Struct({
  start: r.uint16,
  end: r.uint16,
  class: r.uint16
});
var ClassDef = new r.VersionedStruct(r.uint16, {
  1: {
    // Class array
    startGlyph: r.uint16,
    glyphCount: r.uint16,
    classValueArray: new r.Array(r.uint16, 'glyphCount')
  },
  2: {
    // Class ranges
    classRangeCount: r.uint16,
    classRangeRecord: new r.Array(ClassRangeRecord, 'classRangeCount')
  }
}); //###############
// Device Table #
//###############

var Device = new r.Struct({
  a: r.uint16,
  // startSize for hinting Device, outerIndex for VariationIndex
  b: r.uint16,
  // endSize for Device, innerIndex for VariationIndex
  deltaFormat: r.uint16
}); //#############################################
// Contextual Substitution/Positioning Tables #
//#############################################

var LookupRecord = new r.Struct({
  sequenceIndex: r.uint16,
  lookupListIndex: r.uint16
});
var Rule = new r.Struct({
  glyphCount: r.uint16,
  lookupCount: r.uint16,
  input: new r.Array(r.uint16, function (t) {
    return t.glyphCount - 1;
  }),
  lookupRecords: new r.Array(LookupRecord, 'lookupCount')
});
var RuleSet = new r.Array(new r.Pointer(r.uint16, Rule), r.uint16);
var ClassRule = new r.Struct({
  glyphCount: r.uint16,
  lookupCount: r.uint16,
  classes: new r.Array(r.uint16, function (t) {
    return t.glyphCount - 1;
  }),
  lookupRecords: new r.Array(LookupRecord, 'lookupCount')
});
var ClassSet = new r.Array(new r.Pointer(r.uint16, ClassRule), r.uint16);
var Context = new r.VersionedStruct(r.uint16, {
  1: {
    // Simple context
    coverage: new r.Pointer(r.uint16, Coverage),
    ruleSetCount: r.uint16,
    ruleSets: new r.Array(new r.Pointer(r.uint16, RuleSet), 'ruleSetCount')
  },
  2: {
    // Class-based context
    coverage: new r.Pointer(r.uint16, Coverage),
    classDef: new r.Pointer(r.uint16, ClassDef),
    classSetCnt: r.uint16,
    classSet: new r.Array(new r.Pointer(r.uint16, ClassSet), 'classSetCnt')
  },
  3: {
    glyphCount: r.uint16,
    lookupCount: r.uint16,
    coverages: new r.Array(new r.Pointer(r.uint16, Coverage), 'glyphCount'),
    lookupRecords: new r.Array(LookupRecord, 'lookupCount')
  }
}); //######################################################
// Chaining Contextual Substitution/Positioning Tables #
//######################################################

var ChainRule = new r.Struct({
  backtrackGlyphCount: r.uint16,
  backtrack: new r.Array(r.uint16, 'backtrackGlyphCount'),
  inputGlyphCount: r.uint16,
  input: new r.Array(r.uint16, function (t) {
    return t.inputGlyphCount - 1;
  }),
  lookaheadGlyphCount: r.uint16,
  lookahead: new r.Array(r.uint16, 'lookaheadGlyphCount'),
  lookupCount: r.uint16,
  lookupRecords: new r.Array(LookupRecord, 'lookupCount')
});
var ChainRuleSet = new r.Array(new r.Pointer(r.uint16, ChainRule), r.uint16);
var ChainingContext = new r.VersionedStruct(r.uint16, {
  1: {
    // Simple context glyph substitution
    coverage: new r.Pointer(r.uint16, Coverage),
    chainCount: r.uint16,
    chainRuleSets: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')
  },
  2: {
    // Class-based chaining context
    coverage: new r.Pointer(r.uint16, Coverage),
    backtrackClassDef: new r.Pointer(r.uint16, ClassDef),
    inputClassDef: new r.Pointer(r.uint16, ClassDef),
    lookaheadClassDef: new r.Pointer(r.uint16, ClassDef),
    chainCount: r.uint16,
    chainClassSet: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')
  },
  3: {
    // Coverage-based chaining context
    backtrackGlyphCount: r.uint16,
    backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),
    inputGlyphCount: r.uint16,
    inputCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'inputGlyphCount'),
    lookaheadGlyphCount: r.uint16,
    lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),
    lookupCount: r.uint16,
    lookupRecords: new r.Array(LookupRecord, 'lookupCount')
  }
});

var _;
/*******************
 * Variation Store *
 *******************/

var F2DOT14 = new r.Fixed(16, 'BE', 14);
var RegionAxisCoordinates = new r.Struct({
  startCoord: F2DOT14,
  peakCoord: F2DOT14,
  endCoord: F2DOT14
});
var VariationRegionList = new r.Struct({
  axisCount: r.uint16,
  regionCount: r.uint16,
  variationRegions: new r.Array(new r.Array(RegionAxisCoordinates, 'axisCount'), 'regionCount')
});
var DeltaSet = new r.Struct({
  shortDeltas: new r.Array(r.int16, function (t) {
    return t.parent.shortDeltaCount;
  }),
  regionDeltas: new r.Array(r.int8, function (t) {
    return t.parent.regionIndexCount - t.parent.shortDeltaCount;
  }),
  deltas: function deltas(t) {
    return t.shortDeltas.concat(t.regionDeltas);
  }
});
var ItemVariationData = new r.Struct({
  itemCount: r.uint16,
  shortDeltaCount: r.uint16,
  regionIndexCount: r.uint16,
  regionIndexes: new r.Array(r.uint16, 'regionIndexCount'),
  deltaSets: new r.Array(DeltaSet, 'itemCount')
});
var ItemVariationStore = new r.Struct({
  format: r.uint16,
  variationRegionList: new r.Pointer(r.uint32, VariationRegionList),
  variationDataCount: r.uint16,
  itemVariationData: new r.Array(new r.Pointer(r.uint32, ItemVariationData), 'variationDataCount')
});
/**********************
 * Feature Variations *
 **********************/

var ConditionTable = new r.VersionedStruct(r.uint16, {
  1: (_ = {
    axisIndex: r.uint16
  }, _defineProperty(_, "axisIndex", r.uint16), _defineProperty(_, "filterRangeMinValue", F2DOT14), _defineProperty(_, "filterRangeMaxValue", F2DOT14), _)
});
var ConditionSet = new r.Struct({
  conditionCount: r.uint16,
  conditionTable: new r.Array(new r.Pointer(r.uint32, ConditionTable), 'conditionCount')
});
var FeatureTableSubstitutionRecord = new r.Struct({
  featureIndex: r.uint16,
  alternateFeatureTable: new r.Pointer(r.uint32, Feature, {
    type: 'parent'
  })
});
var FeatureTableSubstitution = new r.Struct({
  version: r.fixed32,
  substitutionCount: r.uint16,
  substitutions: new r.Array(FeatureTableSubstitutionRecord, 'substitutionCount')
});
var FeatureVariationRecord = new r.Struct({
  conditionSet: new r.Pointer(r.uint32, ConditionSet, {
    type: 'parent'
  }),
  featureTableSubstitution: new r.Pointer(r.uint32, FeatureTableSubstitution, {
    type: 'parent'
  })
});
var FeatureVariations = new r.Struct({
  majorVersion: r.uint16,
  minorVersion: r.uint16,
  featureVariationRecordCount: r.uint32,
  featureVariationRecords: new r.Array(FeatureVariationRecord, 'featureVariationRecordCount')
});

// otherwise delegates to the provided type.

var PredefinedOp = /*#__PURE__*/function () {
  function PredefinedOp(predefinedOps, type) {
    _classCallCheck(this, PredefinedOp);

    this.predefinedOps = predefinedOps;
    this.type = type;
  }

  _createClass(PredefinedOp, [{
    key: "decode",
    value: function decode(stream, parent, operands) {
      if (this.predefinedOps[operands[0]]) {
        return this.predefinedOps[operands[0]];
      }

      return this.type.decode(stream, parent, operands);
    }
  }, {
    key: "size",
    value: function size(value, ctx) {
      return this.type.size(value, ctx);
    }
  }, {
    key: "encode",
    value: function encode(stream, value, ctx) {
      var index = this.predefinedOps.indexOf(value);

      if (index !== -1) {
        return index;
      }

      return this.type.encode(stream, value, ctx);
    }
  }]);

  return PredefinedOp;
}();

var CFFEncodingVersion = /*#__PURE__*/function (_r$Number) {
  _inherits(CFFEncodingVersion, _r$Number);

  var _super = _createSuper(CFFEncodingVersion);

  function CFFEncodingVersion() {
    _classCallCheck(this, CFFEncodingVersion);

    return _super.call(this, 'UInt8');
  }

  _createClass(CFFEncodingVersion, [{
    key: "decode",
    value: function decode(stream) {
      return r.uint8.decode(stream) & 0x7f;
    }
  }]);

  return CFFEncodingVersion;
}(r.Number);

var Range1 = new r.Struct({
  first: r.uint16,
  nLeft: r.uint8
});
var Range2 = new r.Struct({
  first: r.uint16,
  nLeft: r.uint16
});
var CFFCustomEncoding = new r.VersionedStruct(new CFFEncodingVersion(), {
  0: {
    nCodes: r.uint8,
    codes: new r.Array(r.uint8, 'nCodes')
  },
  1: {
    nRanges: r.uint8,
    ranges: new r.Array(Range1, 'nRanges')
  } // TODO: supplement?

});
var CFFEncoding = new PredefinedOp([StandardEncoding, ExpertEncoding], new CFFPointer(CFFCustomEncoding, {
  lazy: true
})); // Decodes an array of ranges until the total
// length is equal to the provided length.

var RangeArray = /*#__PURE__*/function (_r$Array) {
  _inherits(RangeArray, _r$Array);

  var _super2 = _createSuper(RangeArray);

  function RangeArray() {
    _classCallCheck(this, RangeArray);

    return _super2.apply(this, arguments);
  }

  _createClass(RangeArray, [{
    key: "decode",
    value: function decode(stream, parent) {
      var length = utils.resolveLength(this.length, stream, parent);
      var count = 0;
      var res = [];

      while (count < length) {
        var range = this.type.decode(stream, parent);
        range.offset = count;
        count += range.nLeft + 1;
        res.push(range);
      }

      return res;
    }
  }]);

  return RangeArray;
}(r.Array);

var CFFCustomCharset = new r.VersionedStruct(r.uint8, {
  0: {
    glyphs: new r.Array(r.uint16, function (t) {
      return t.parent.CharStrings.length - 1;
    })
  },
  1: {
    ranges: new RangeArray(Range1, function (t) {
      return t.parent.CharStrings.length - 1;
    })
  },
  2: {
    ranges: new RangeArray(Range2, function (t) {
      return t.parent.CharStrings.length - 1;
    })
  }
});
var CFFCharset = new PredefinedOp([ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset], new CFFPointer(CFFCustomCharset, {
  lazy: true
}));
var FDRange3 = new r.Struct({
  first: r.uint16,
  fd: r.uint8
});
var FDRange4 = new r.Struct({
  first: r.uint32,
  fd: r.uint16
});
var FDSelect = new r.VersionedStruct(r.uint8, {
  0: {
    fds: new r.Array(r.uint8, function (t) {
      return t.parent.CharStrings.length;
    })
  },
  3: {
    nRanges: r.uint16,
    ranges: new r.Array(FDRange3, 'nRanges'),
    sentinel: r.uint16
  },
  4: {
    nRanges: r.uint32,
    ranges: new r.Array(FDRange4, 'nRanges'),
    sentinel: r.uint32
  }
});
var ptr = new CFFPointer(CFFPrivateDict);

var CFFPrivateOp = /*#__PURE__*/function () {
  function CFFPrivateOp() {
    _classCallCheck(this, CFFPrivateOp);
  }

  _createClass(CFFPrivateOp, [{
    key: "decode",
    value: function decode(stream, parent, operands) {
      parent.length = operands[0];
      return ptr.decode(stream, parent, [operands[1]]);
    }
  }, {
    key: "size",
    value: function size(dict, ctx) {
      return [CFFPrivateDict.size(dict, ctx, false), ptr.size(dict, ctx)[0]];
    }
  }, {
    key: "encode",
    value: function encode(stream, dict, ctx) {
      return [CFFPrivateDict.size(dict, ctx, false), ptr.encode(stream, dict, ctx)[0]];
    }
  }]);

  return CFFPrivateOp;
}();

var FontDict = new CFFDict([// key       name                   type(s)                                 default
[18, 'Private', new CFFPrivateOp(), null], [[12, 38], 'FontName', 'sid', null], [[12, 7], 'FontMatrix', 'array', [0.001, 0, 0, 0.001, 0, 0]], [[12, 5], 'PaintType', 'number', 0]]);
var CFFTopDict = new CFFDict([// key       name                   type(s)                                 default
[[12, 30], 'ROS', ['sid', 'sid', 'number'], null], [0, 'version', 'sid', null], [1, 'Notice', 'sid', null], [[12, 0], 'Copyright', 'sid', null], [2, 'FullName', 'sid', null], [3, 'FamilyName', 'sid', null], [4, 'Weight', 'sid', null], [[12, 1], 'isFixedPitch', 'boolean', false], [[12, 2], 'ItalicAngle', 'number', 0], [[12, 3], 'UnderlinePosition', 'number', -100], [[12, 4], 'UnderlineThickness', 'number', 50], [[12, 5], 'PaintType', 'number', 0], [[12, 6], 'CharstringType', 'number', 2], [[12, 7], 'FontMatrix', 'array', [0.001, 0, 0, 0.001, 0, 0]], [13, 'UniqueID', 'number', null], [5, 'FontBBox', 'array', [0, 0, 0, 0]], [[12, 8], 'StrokeWidth', 'number', 0], [14, 'XUID', 'array', null], [15, 'charset', CFFCharset, ISOAdobeCharset], [16, 'Encoding', CFFEncoding, StandardEncoding], [17, 'CharStrings', new CFFPointer(new CFFIndex()), null], [18, 'Private', new CFFPrivateOp(), null], [[12, 20], 'SyntheticBase', 'number', null], [[12, 21], 'PostScript', 'sid', null], [[12, 22], 'BaseFontName', 'sid', null], [[12, 23], 'BaseFontBlend', 'delta', null], // CID font specific
[[12, 31], 'CIDFontVersion', 'number', 0], [[12, 32], 'CIDFontRevision', 'number', 0], [[12, 33], 'CIDFontType', 'number', 0], [[12, 34], 'CIDCount', 'number', 8720], [[12, 35], 'UIDBase', 'number', null], [[12, 37], 'FDSelect', new CFFPointer(FDSelect), null], [[12, 36], 'FDArray', new CFFPointer(new CFFIndex(FontDict)), null], [[12, 38], 'FontName', 'sid', null]]);
var VariationStore = new r.Struct({
  length: r.uint16,
  itemVariationStore: ItemVariationStore
});
var CFF2TopDict = new CFFDict([[[12, 7], 'FontMatrix', 'array', [0.001, 0, 0, 0.001, 0, 0]], [17, 'CharStrings', new CFFPointer(new CFFIndex()), null], [[12, 37], 'FDSelect', new CFFPointer(FDSelect), null], [[12, 36], 'FDArray', new CFFPointer(new CFFIndex(FontDict)), null], [24, 'vstore', new CFFPointer(VariationStore), null], [25, 'maxstack', 'number', 193]]);
var CFFTop = new r.VersionedStruct(r.fixed16, {
  1: {
    hdrSize: r.uint8,
    offSize: r.uint8,
    nameIndex: new CFFIndex(new r.String('length')),
    topDictIndex: new CFFIndex(CFFTopDict),
    stringIndex: new CFFIndex(new r.String('length')),
    globalSubrIndex: new CFFIndex()
  },
  2: {
    hdrSize: r.uint8,
    length: r.uint16,
    topDict: CFF2TopDict,
    globalSubrIndex: new CFFIndex()
  }
});

var CFFFont = /*#__PURE__*/function () {
  function CFFFont(stream) {
    _classCallCheck(this, CFFFont);

    this.stream = stream;
    this.decode();
  }

  _createClass(CFFFont, [{
    key: "decode",
    value: function decode() {
      var start = this.stream.pos;
      var top = CFFTop.decode(this.stream);

      for (var key in top) {
        var val = top[key];
        this[key] = val;
      }

      if (this.version < 2) {
        if (this.topDictIndex.length !== 1) {
          throw new Error("Only a single font is allowed in CFF");
        }

        this.topDict = this.topDictIndex[0];
      }

      this.isCIDFont = this.topDict.ROS != null;
      return this;
    }
  }, {
    key: "string",
    value: function string(sid) {
      if (this.version >= 2) {
        return null;
      }

      if (sid < standardStrings.length) {
        return standardStrings[sid];
      }

      return this.stringIndex[sid - standardStrings.length];
    }
  }, {
    key: "postscriptName",
    get: function get() {
      if (this.version < 2) {
        return this.nameIndex[0];
      }

      return null;
    }
  }, {
    key: "fullName",
    get: function get() {
      return this.string(this.topDict.FullName);
    }
  }, {
    key: "familyName",
    get: function get() {
      return this.string(this.topDict.FamilyName);
    }
  }, {
    key: "getCharString",
    value: function getCharString(glyph) {
      this.stream.pos = this.topDict.CharStrings[glyph].offset;
      return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
    }
  }, {
    key: "getGlyphName",
    value: function getGlyphName(gid) {
      // CFF2 glyph names are in the post table.
      if (this.version >= 2) {
        return null;
      } // CID-keyed fonts don't have glyph names


      if (this.isCIDFont) {
        return null;
      }

      var charset = this.topDict.charset;

      if (Array.isArray(charset)) {
        return charset[gid];
      }

      if (gid === 0) {
        return '.notdef';
      }

      gid -= 1;

      switch (charset.version) {
        case 0:
          return this.string(charset.glyphs[gid]);

        case 1:
        case 2:
          for (var i = 0; i < charset.ranges.length; i++) {
            var range = charset.ranges[i];

            if (range.offset <= gid && gid <= range.offset + range.nLeft) {
              return this.string(range.first + (gid - range.offset));
            }
          }

          break;
      }

      return null;
    }
  }, {
    key: "fdForGlyph",
    value: function fdForGlyph(gid) {
      if (!this.topDict.FDSelect) {
        return null;
      }

      switch (this.topDict.FDSelect.version) {
        case 0:
          return this.topDict.FDSelect.fds[gid];

        case 3:
        case 4:
          var ranges = this.topDict.FDSelect.ranges;
          var low = 0;
          var high = ranges.length - 1;

          while (low <= high) {
            var mid = low + high >> 1;

            if (gid < ranges[mid].first) {
              high = mid - 1;
            } else if (mid < high && gid >= ranges[mid + 1].first) {
              low = mid + 1;
            } else {
              return ranges[mid].fd;
            }
          }

        default:
          throw new Error("Unknown FDSelect version: ".concat(this.topDict.FDSelect.version));
      }
    }
  }, {
    key: "privateDictForGlyph",
    value: function privateDictForGlyph(gid) {
      if (this.topDict.FDSelect) {
        var fd = this.fdForGlyph(gid);

        if (this.topDict.FDArray[fd]) {
          return this.topDict.FDArray[fd].Private;
        }

        return null;
      }

      if (this.version < 2) {
        return this.topDict.Private;
      }

      return this.topDict.FDArray[0].Private;
    }
  }], [{
    key: "decode",
    value: function decode(stream) {
      return new CFFFont(stream);
    }
  }]);

  return CFFFont;
}();

var VerticalOrigin = new r.Struct({
  glyphIndex: r.uint16,
  vertOriginY: r.int16
});
var VORG = new r.Struct({
  majorVersion: r.uint16,
  minorVersion: r.uint16,
  defaultVertOriginY: r.int16,
  numVertOriginYMetrics: r.uint16,
  metrics: new r.Array(VerticalOrigin, 'numVertOriginYMetrics')
});

var BigMetrics = new r.Struct({
  height: r.uint8,
  width: r.uint8,
  horiBearingX: r.int8,
  horiBearingY: r.int8,
  horiAdvance: r.uint8,
  vertBearingX: r.int8,
  vertBearingY: r.int8,
  vertAdvance: r.uint8
});
var SmallMetrics = new r.Struct({
  height: r.uint8,
  width: r.uint8,
  bearingX: r.int8,
  bearingY: r.int8,
  advance: r.uint8
});
var EBDTComponent = new r.Struct({
  glyph: r.uint16,
  xOffset: r.int8,
  yOffset: r.int8
});

var ByteAligned = function ByteAligned() {
  _classCallCheck(this, ByteAligned);
};

var BitAligned = function BitAligned() {
  _classCallCheck(this, BitAligned);
};

var glyph = new r.VersionedStruct('version', {
  1: {
    metrics: SmallMetrics,
    data: ByteAligned
  },
  2: {
    metrics: SmallMetrics,
    data: BitAligned
  },
  // format 3 is deprecated
  // format 4 is not supported by Microsoft
  5: {
    data: BitAligned
  },
  6: {
    metrics: BigMetrics,
    data: ByteAligned
  },
  7: {
    metrics: BigMetrics,
    data: BitAligned
  },
  8: {
    metrics: SmallMetrics,
    pad: new r.Reserved(r.uint8),
    numComponents: r.uint16,
    components: new r.Array(EBDTComponent, 'numComponents')
  },
  9: {
    metrics: BigMetrics,
    pad: new r.Reserved(r.uint8),
    numComponents: r.uint16,
    components: new r.Array(EBDTComponent, 'numComponents')
  },
  17: {
    metrics: SmallMetrics,
    dataLen: r.uint32,
    data: new r.Buffer('dataLen')
  },
  18: {
    metrics: BigMetrics,
    dataLen: r.uint32,
    data: new r.Buffer('dataLen')
  },
  19: {
    dataLen: r.uint32,
    data: new r.Buffer('dataLen')
  }
});

var SBitLineMetrics = new r.Struct({
  ascender: r.int8,
  descender: r.int8,
  widthMax: r.uint8,
  caretSlopeNumerator: r.int8,
  caretSlopeDenominator: r.int8,
  caretOffset: r.int8,
  minOriginSB: r.int8,
  minAdvanceSB: r.int8,
  maxBeforeBL: r.int8,
  minAfterBL: r.int8,
  pad: new r.Reserved(r.int8, 2)
});
var CodeOffsetPair = new r.Struct({
  glyphCode: r.uint16,
  offset: r.uint16
});
var IndexSubtable = new r.VersionedStruct(r.uint16, {
  header: {
    imageFormat: r.uint16,
    imageDataOffset: r.uint32
  },
  1: {
    offsetArray: new r.Array(r.uint32, function (t) {
      return t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1;
    })
  },
  2: {
    imageSize: r.uint32,
    bigMetrics: BigMetrics
  },
  3: {
    offsetArray: new r.Array(r.uint16, function (t) {
      return t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1;
    })
  },
  4: {
    numGlyphs: r.uint32,
    glyphArray: new r.Array(CodeOffsetPair, function (t) {
      return t.numGlyphs + 1;
    })
  },
  5: {
    imageSize: r.uint32,
    bigMetrics: BigMetrics,
    numGlyphs: r.uint32,
    glyphCodeArray: new r.Array(r.uint16, 'numGlyphs')
  }
});
var IndexSubtableArray = new r.Struct({
  firstGlyphIndex: r.uint16,
  lastGlyphIndex: r.uint16,
  subtable: new r.Pointer(r.uint32, IndexSubtable)
});
var BitmapSizeTable = new r.Struct({
  indexSubTableArray: new r.Pointer(r.uint32, new r.Array(IndexSubtableArray, 1), {
    type: 'parent'
  }),
  indexTablesSize: r.uint32,
  numberOfIndexSubTables: r.uint32,
  colorRef: r.uint32,
  hori: SBitLineMetrics,
  vert: SBitLineMetrics,
  startGlyphIndex: r.uint16,
  endGlyphIndex: r.uint16,
  ppemX: r.uint8,
  ppemY: r.uint8,
  bitDepth: r.uint8,
  flags: new r.Bitfield(r.uint8, ['horizontal', 'vertical'])
});
var EBLC = new r.Struct({
  version: r.uint32,
  // 0x00020000
  numSizes: r.uint32,
  sizes: new r.Array(BitmapSizeTable, 'numSizes')
});

var ImageTable = new r.Struct({
  ppem: r.uint16,
  resolution: r.uint16,
  imageOffsets: new r.Array(new r.Pointer(r.uint32, 'void'), function (t) {
    return t.parent.parent.maxp.numGlyphs + 1;
  })
}); // This is the Apple sbix table, used by the "Apple Color Emoji" font.
// It includes several image tables with images for each bitmap glyph
// of several different sizes.

var sbix = new r.Struct({
  version: r.uint16,
  flags: new r.Bitfield(r.uint16, ['renderOutlines']),
  numImgTables: r.uint32,
  imageTables: new r.Array(new r.Pointer(r.uint32, ImageTable), 'numImgTables')
});

var LayerRecord = new r.Struct({
  gid: r.uint16,
  // Glyph ID of layer glyph (must be in z-order from bottom to top).
  paletteIndex: r.uint16 // Index value to use in the appropriate palette. This value must

}); // be less than numPaletteEntries in the CPAL table, except for
// the special case noted below. Each palette entry is 16 bits.
// A palette index of 0xFFFF is a special case indicating that
// the text foreground color should be used.

var BaseGlyphRecord = new r.Struct({
  gid: r.uint16,
  // Glyph ID of reference glyph. This glyph is for reference only
  // and is not rendered for color.
  firstLayerIndex: r.uint16,
  // Index (from beginning of the Layer Records) to the layer record.
  // There will be numLayers consecutive entries for this base glyph.
  numLayers: r.uint16
});
var COLR = new r.Struct({
  version: r.uint16,
  numBaseGlyphRecords: r.uint16,
  baseGlyphRecord: new r.Pointer(r.uint32, new r.Array(BaseGlyphRecord, 'numBaseGlyphRecords')),
  layerRecords: new r.Pointer(r.uint32, new r.Array(LayerRecord, 'numLayerRecords'), {
    lazy: true
  }),
  numLayerRecords: r.uint16
});

var ColorRecord = new r.Struct({
  blue: r.uint8,
  green: r.uint8,
  red: r.uint8,
  alpha: r.uint8
});
var CPAL = new r.VersionedStruct(r.uint16, {
  header: {
    numPaletteEntries: r.uint16,
    numPalettes: r.uint16,
    numColorRecords: r.uint16,
    colorRecords: new r.Pointer(r.uint32, new r.Array(ColorRecord, 'numColorRecords')),
    colorRecordIndices: new r.Array(r.uint16, 'numPalettes')
  },
  0: {},
  1: {
    offsetPaletteTypeArray: new r.Pointer(r.uint32, new r.Array(r.uint32, 'numPalettes')),
    offsetPaletteLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPalettes')),
    offsetPaletteEntryLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPaletteEntries'))
  }
});

var BaseCoord = new r.VersionedStruct(r.uint16, {
  1: {
    // Design units only
    coordinate: r.int16 // X or Y value, in design units

  },
  2: {
    // Design units plus contour point
    coordinate: r.int16,
    // X or Y value, in design units
    referenceGlyph: r.uint16,
    // GlyphID of control glyph
    baseCoordPoint: r.uint16 // Index of contour point on the referenceGlyph

  },
  3: {
    // Design units plus Device table
    coordinate: r.int16,
    // X or Y value, in design units
    deviceTable: new r.Pointer(r.uint16, Device) // Device table for X or Y value

  }
});
var BaseValues = new r.Struct({
  defaultIndex: r.uint16,
  // Index of default baseline for this script-same index in the BaseTagList
  baseCoordCount: r.uint16,
  baseCoords: new r.Array(new r.Pointer(r.uint16, BaseCoord), 'baseCoordCount')
});
var FeatMinMaxRecord = new r.Struct({
  tag: new r.String(4),
  // 4-byte feature identification tag-must match FeatureTag in FeatureList
  minCoord: new r.Pointer(r.uint16, BaseCoord, {
    type: 'parent'
  }),
  // May be NULL
  maxCoord: new r.Pointer(r.uint16, BaseCoord, {
    type: 'parent'
  }) // May be NULL

});
var MinMax = new r.Struct({
  minCoord: new r.Pointer(r.uint16, BaseCoord),
  // May be NULL
  maxCoord: new r.Pointer(r.uint16, BaseCoord),
  // May be NULL
  featMinMaxCount: r.uint16,
  // May be 0
  featMinMaxRecords: new r.Array(FeatMinMaxRecord, 'featMinMaxCount') // In alphabetical order

});
var BaseLangSysRecord = new r.Struct({
  tag: new r.String(4),
  // 4-byte language system identification tag
  minMax: new r.Pointer(r.uint16, MinMax, {
    type: 'parent'
  })
});
var BaseScript = new r.Struct({
  baseValues: new r.Pointer(r.uint16, BaseValues),
  // May be NULL
  defaultMinMax: new r.Pointer(r.uint16, MinMax),
  // May be NULL
  baseLangSysCount: r.uint16,
  // May be 0
  baseLangSysRecords: new r.Array(BaseLangSysRecord, 'baseLangSysCount') // in alphabetical order by BaseLangSysTag

});
var BaseScriptRecord = new r.Struct({
  tag: new r.String(4),
  // 4-byte script identification tag
  script: new r.Pointer(r.uint16, BaseScript, {
    type: 'parent'
  })
});
var BaseScriptList = new r.Array(BaseScriptRecord, r.uint16); // Array of 4-byte baseline identification tags-must be in alphabetical order

var BaseTagList = new r.Array(new r.String(4), r.uint16);
var Axis = new r.Struct({
  baseTagList: new r.Pointer(r.uint16, BaseTagList),
  // May be NULL
  baseScriptList: new r.Pointer(r.uint16, BaseScriptList)
});
var BASE = new r.VersionedStruct(r.uint32, {
  header: {
    horizAxis: new r.Pointer(r.uint16, Axis),
    // May be NULL
    vertAxis: new r.Pointer(r.uint16, Axis) // May be NULL

  },
  0x00010000: {},
  0x00010001: {
    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)
  }
});

var AttachPoint = new r.Array(r.uint16, r.uint16);
var AttachList = new r.Struct({
  coverage: new r.Pointer(r.uint16, Coverage),
  glyphCount: r.uint16,
  attachPoints: new r.Array(new r.Pointer(r.uint16, AttachPoint), 'glyphCount')
});
var CaretValue = new r.VersionedStruct(r.uint16, {
  1: {
    // Design units only
    coordinate: r.int16
  },
  2: {
    // Contour point
    caretValuePoint: r.uint16
  },
  3: {
    // Design units plus Device table
    coordinate: r.int16,
    deviceTable: new r.Pointer(r.uint16, Device)
  }
});
var LigGlyph = new r.Array(new r.Pointer(r.uint16, CaretValue), r.uint16);
var LigCaretList = new r.Struct({
  coverage: new r.Pointer(r.uint16, Coverage),
  ligGlyphCount: r.uint16,
  ligGlyphs: new r.Array(new r.Pointer(r.uint16, LigGlyph), 'ligGlyphCount')
});
var MarkGlyphSetsDef = new r.Struct({
  markSetTableFormat: r.uint16,
  markSetCount: r.uint16,
  coverage: new r.Array(new r.Pointer(r.uint32, Coverage), 'markSetCount')
});
var GDEF = new r.VersionedStruct(r.uint32, {
  header: {
    glyphClassDef: new r.Pointer(r.uint16, ClassDef),
    attachList: new r.Pointer(r.uint16, AttachList),
    ligCaretList: new r.Pointer(r.uint16, LigCaretList),
    markAttachClassDef: new r.Pointer(r.uint16, ClassDef)
  },
  0x00010000: {},
  0x00010002: {
    markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef)
  },
  0x00010003: {
    markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef),
    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)
  }
});

var ValueFormat = new r.Bitfield(r.uint16, ['xPlacement', 'yPlacement', 'xAdvance', 'yAdvance', 'xPlaDevice', 'yPlaDevice', 'xAdvDevice', 'yAdvDevice']);
var types = {
  xPlacement: r.int16,
  yPlacement: r.int16,
  xAdvance: r.int16,
  yAdvance: r.int16,
  xPlaDevice: new r.Pointer(r.uint16, Device, {
    type: 'global',
    relativeTo: function relativeTo(ctx) {
      return ctx.rel;
    }
  }),
  yPlaDevice: new r.Pointer(r.uint16, Device, {
    type: 'global',
    relativeTo: function relativeTo(ctx) {
      return ctx.rel;
    }
  }),
  xAdvDevice: new r.Pointer(r.uint16, Device, {
    type: 'global',
    relativeTo: function relativeTo(ctx) {
      return ctx.rel;
    }
  }),
  yAdvDevice: new r.Pointer(r.uint16, Device, {
    type: 'global',
    relativeTo: function relativeTo(ctx) {
      return ctx.rel;
    }
  })
};

var ValueRecord = /*#__PURE__*/function () {
  function ValueRecord() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'valueFormat';

    _classCallCheck(this, ValueRecord);

    this.key = key;
  }

  _createClass(ValueRecord, [{
    key: "buildStruct",
    value: function buildStruct(parent) {
      var struct = parent;

      while (!struct[this.key] && struct.parent) {
        struct = struct.parent;
      }

      if (!struct[this.key]) return;
      var fields = {};

      fields.rel = function () {
        return struct._startOffset;
      };

      var format = struct[this.key];

      for (var key in format) {
        if (format[key]) {
          fields[key] = types[key];
        }
      }

      return new r.Struct(fields);
    }
  }, {
    key: "size",
    value: function size(val, ctx) {
      return this.buildStruct(ctx).size(val, ctx);
    }
  }, {
    key: "decode",
    value: function decode(stream, parent) {
      var res = this.buildStruct(parent).decode(stream, parent);
      delete res.rel;
      return res;
    }
  }]);

  return ValueRecord;
}();

var PairValueRecord = new r.Struct({
  secondGlyph: r.uint16,
  value1: new ValueRecord('valueFormat1'),
  value2: new ValueRecord('valueFormat2')
});
var PairSet = new r.Array(PairValueRecord, r.uint16);
var Class2Record = new r.Struct({
  value1: new ValueRecord('valueFormat1'),
  value2: new ValueRecord('valueFormat2')
});
var Anchor = new r.VersionedStruct(r.uint16, {
  1: {
    // Design units only
    xCoordinate: r.int16,
    yCoordinate: r.int16
  },
  2: {
    // Design units plus contour point
    xCoordinate: r.int16,
    yCoordinate: r.int16,
    anchorPoint: r.uint16
  },
  3: {
    // Design units plus Device tables
    xCoordinate: r.int16,
    yCoordinate: r.int16,
    xDeviceTable: new r.Pointer(r.uint16, Device),
    yDeviceTable: new r.Pointer(r.uint16, Device)
  }
});
var EntryExitRecord = new r.Struct({
  entryAnchor: new r.Pointer(r.uint16, Anchor, {
    type: 'parent'
  }),
  exitAnchor: new r.Pointer(r.uint16, Anchor, {
    type: 'parent'
  })
});
var MarkRecord = new r.Struct({
  class: r.uint16,
  markAnchor: new r.Pointer(r.uint16, Anchor, {
    type: 'parent'
  })
});
var MarkArray = new r.Array(MarkRecord, r.uint16);
var BaseRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function (t) {
  return t.parent.classCount;
});
var BaseArray = new r.Array(BaseRecord, r.uint16);
var ComponentRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function (t) {
  return t.parent.parent.classCount;
});
var LigatureAttach = new r.Array(ComponentRecord, r.uint16);
var LigatureArray = new r.Array(new r.Pointer(r.uint16, LigatureAttach), r.uint16);
var GPOSLookup = new r.VersionedStruct('lookupType', {
  1: new r.VersionedStruct(r.uint16, {
    // Single Adjustment
    1: {
      // Single positioning value
      coverage: new r.Pointer(r.uint16, Coverage),
      valueFormat: ValueFormat,
      value: new ValueRecord()
    },
    2: {
      coverage: new r.Pointer(r.uint16, Coverage),
      valueFormat: ValueFormat,
      valueCount: r.uint16,
      values: new r.LazyArray(new ValueRecord(), 'valueCount')
    }
  }),
  2: new r.VersionedStruct(r.uint16, {
    // Pair Adjustment Positioning
    1: {
      // Adjustments for glyph pairs
      coverage: new r.Pointer(r.uint16, Coverage),
      valueFormat1: ValueFormat,
      valueFormat2: ValueFormat,
      pairSetCount: r.uint16,
      pairSets: new r.LazyArray(new r.Pointer(r.uint16, PairSet), 'pairSetCount')
    },
    2: {
      // Class pair adjustment
      coverage: new r.Pointer(r.uint16, Coverage),
      valueFormat1: ValueFormat,
      valueFormat2: ValueFormat,
      classDef1: new r.Pointer(r.uint16, ClassDef),
      classDef2: new r.Pointer(r.uint16, ClassDef),
      class1Count: r.uint16,
      class2Count: r.uint16,
      classRecords: new r.LazyArray(new r.LazyArray(Class2Record, 'class2Count'), 'class1Count')
    }
  }),
  3: {
    // Cursive Attachment Positioning
    format: r.uint16,
    coverage: new r.Pointer(r.uint16, Coverage),
    entryExitCount: r.uint16,
    entryExitRecords: new r.Array(EntryExitRecord, 'entryExitCount')
  },
  4: {
    // MarkToBase Attachment Positioning
    format: r.uint16,
    markCoverage: new r.Pointer(r.uint16, Coverage),
    baseCoverage: new r.Pointer(r.uint16, Coverage),
    classCount: r.uint16,
    markArray: new r.Pointer(r.uint16, MarkArray),
    baseArray: new r.Pointer(r.uint16, BaseArray)
  },
  5: {
    // MarkToLigature Attachment Positioning
    format: r.uint16,
    markCoverage: new r.Pointer(r.uint16, Coverage),
    ligatureCoverage: new r.Pointer(r.uint16, Coverage),
    classCount: r.uint16,
    markArray: new r.Pointer(r.uint16, MarkArray),
    ligatureArray: new r.Pointer(r.uint16, LigatureArray)
  },
  6: {
    // MarkToMark Attachment Positioning
    format: r.uint16,
    mark1Coverage: new r.Pointer(r.uint16, Coverage),
    mark2Coverage: new r.Pointer(r.uint16, Coverage),
    classCount: r.uint16,
    mark1Array: new r.Pointer(r.uint16, MarkArray),
    mark2Array: new r.Pointer(r.uint16, BaseArray)
  },
  7: Context,
  // Contextual positioning
  8: ChainingContext,
  // Chaining contextual positioning
  9: {
    // Extension Positioning
    posFormat: r.uint16,
    lookupType: r.uint16,
    // cannot also be 9
    extension: new r.Pointer(r.uint32, GPOSLookup)
  }
}); // Fix circular reference

GPOSLookup.versions[9].extension.type = GPOSLookup;
var GPOS = new r.VersionedStruct(r.uint32, {
  header: {
    scriptList: new r.Pointer(r.uint16, ScriptList),
    featureList: new r.Pointer(r.uint16, FeatureList),
    lookupList: new r.Pointer(r.uint16, new LookupList(GPOSLookup))
  },
  0x00010000: {},
  0x00010001: {
    featureVariations: new r.Pointer(r.uint32, FeatureVariations)
  }
}); // export GPOSLookup for JSTF table

var Sequence = new r.Array(r.uint16, r.uint16);
var AlternateSet = Sequence;
var Ligature = new r.Struct({
  glyph: r.uint16,
  compCount: r.uint16,
  components: new r.Array(r.uint16, function (t) {
    return t.compCount - 1;
  })
});
var LigatureSet = new r.Array(new r.Pointer(r.uint16, Ligature), r.uint16);
var GSUBLookup = new r.VersionedStruct('lookupType', {
  1: new r.VersionedStruct(r.uint16, {
    // Single Substitution
    1: {
      coverage: new r.Pointer(r.uint16, Coverage),
      deltaGlyphID: r.int16
    },
    2: {
      coverage: new r.Pointer(r.uint16, Coverage),
      glyphCount: r.uint16,
      substitute: new r.LazyArray(r.uint16, 'glyphCount')
    }
  }),
  2: {
    // Multiple Substitution
    substFormat: r.uint16,
    coverage: new r.Pointer(r.uint16, Coverage),
    count: r.uint16,
    sequences: new r.LazyArray(new r.Pointer(r.uint16, Sequence), 'count')
  },
  3: {
    // Alternate Substitution
    substFormat: r.uint16,
    coverage: new r.Pointer(r.uint16, Coverage),
    count: r.uint16,
    alternateSet: new r.LazyArray(new r.Pointer(r.uint16, AlternateSet), 'count')
  },
  4: {
    // Ligature Substitution
    substFormat: r.uint16,
    coverage: new r.Pointer(r.uint16, Coverage),
    count: r.uint16,
    ligatureSets: new r.LazyArray(new r.Pointer(r.uint16, LigatureSet), 'count')
  },
  5: Context,
  // Contextual Substitution
  6: ChainingContext,
  // Chaining Contextual Substitution
  7: {
    // Extension Substitution
    substFormat: r.uint16,
    lookupType: r.uint16,
    // cannot also be 7
    extension: new r.Pointer(r.uint32, GSUBLookup)
  },
  8: {
    // Reverse Chaining Contextual Single Substitution
    substFormat: r.uint16,
    coverage: new r.Pointer(r.uint16, Coverage),
    backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),
    lookaheadGlyphCount: r.uint16,
    lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),
    glyphCount: r.uint16,
    substitutes: new r.Array(r.uint16, 'glyphCount')
  }
}); // Fix circular reference

GSUBLookup.versions[7].extension.type = GSUBLookup;
var GSUB = new r.VersionedStruct(r.uint32, {
  header: {
    scriptList: new r.Pointer(r.uint16, ScriptList),
    featureList: new r.Pointer(r.uint16, FeatureList),
    lookupList: new r.Pointer(r.uint16, new LookupList(GSUBLookup))
  },
  0x00010000: {},
  0x00010001: {
    featureVariations: new r.Pointer(r.uint32, FeatureVariations)
  }
});

var JstfGSUBModList = new r.Array(r.uint16, r.uint16);
var JstfPriority = new r.Struct({
  shrinkageEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
  shrinkageDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
  shrinkageEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
  shrinkageDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
  shrinkageJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup)),
  extensionEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
  extensionDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
  extensionEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
  extensionDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
  extensionJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup))
});
var JstfLangSys = new r.Array(new r.Pointer(r.uint16, JstfPriority), r.uint16);
var JstfLangSysRecord = new r.Struct({
  tag: new r.String(4),
  jstfLangSys: new r.Pointer(r.uint16, JstfLangSys)
});
var JstfScript = new r.Struct({
  extenderGlyphs: new r.Pointer(r.uint16, new r.Array(r.uint16, r.uint16)),
  // array of glyphs to extend line length
  defaultLangSys: new r.Pointer(r.uint16, JstfLangSys),
  langSysCount: r.uint16,
  langSysRecords: new r.Array(JstfLangSysRecord, 'langSysCount')
});
var JstfScriptRecord = new r.Struct({
  tag: new r.String(4),
  script: new r.Pointer(r.uint16, JstfScript, {
    type: 'parent'
  })
});
var JSTF = new r.Struct({
  version: r.uint32,
  // should be 0x00010000
  scriptCount: r.uint16,
  scriptList: new r.Array(JstfScriptRecord, 'scriptCount')
});

var VariableSizeNumber = /*#__PURE__*/function () {
  function VariableSizeNumber(size) {
    _classCallCheck(this, VariableSizeNumber);

    this._size = size;
  }

  _createClass(VariableSizeNumber, [{
    key: "decode",
    value: function decode(stream, parent) {
      switch (this.size(0, parent)) {
        case 1:
          return stream.readUInt8();

        case 2:
          return stream.readUInt16BE();

        case 3:
          return stream.readUInt24BE();

        case 4:
          return stream.readUInt32BE();
      }
    }
  }, {
    key: "size",
    value: function size(val, parent) {
      return utils.resolveLength(this._size, null, parent);
    }
  }]);

  return VariableSizeNumber;
}();

var MapDataEntry = new r.Struct({
  entry: new VariableSizeNumber(function (t) {
    return ((t.parent.entryFormat & 0x0030) >> 4) + 1;
  }),
  outerIndex: function outerIndex(t) {
    return t.entry >> (t.parent.entryFormat & 0x000F) + 1;
  },
  innerIndex: function innerIndex(t) {
    return t.entry & (1 << (t.parent.entryFormat & 0x000F) + 1) - 1;
  }
});
var DeltaSetIndexMap = new r.Struct({
  entryFormat: r.uint16,
  mapCount: r.uint16,
  mapData: new r.Array(MapDataEntry, 'mapCount')
});
var HVAR = new r.Struct({
  majorVersion: r.uint16,
  minorVersion: r.uint16,
  itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore),
  advanceWidthMapping: new r.Pointer(r.uint32, DeltaSetIndexMap